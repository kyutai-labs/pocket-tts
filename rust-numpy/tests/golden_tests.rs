//! Golden Data Conformance Verification Tests
//!
//! This module loads test data generated by the Python NumPy reference implementation
//! and verifies that the rust-numpy implementation produces identical results.

use numpy::dtype::Casting;
use numpy::Array;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

/// Golden data structure matching the Python output format
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GoldenData {
    pub metadata: Metadata,
    pub test_cases: Vec<TestCase>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Metadata {
    pub version: String,
    pub numpy_version: String,
    pub seed: u64,
    pub num_cases: usize,
    pub generated_at: String,
    pub description: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCase {
    pub id: String,
    pub input: ArrayData,
    pub operands: Option<Operands>,
    pub operations: Operations,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Operations {
    pub basic: Option<BasicOps>,
    pub reductions: Option<ReductionOps>,
    pub ufuncs: Option<UfuncOps>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Operands {
    #[serde(default)]
    pub binary: std::collections::HashMap<String, ArrayData>,
    #[serde(default)]
    pub comparison: std::collections::HashMap<String, ArrayData>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicOps {
    pub sum: Option<ArrayData>,
    pub mean: Option<ArrayData>,
    pub min: Option<ArrayData>,
    pub max: Option<ArrayData>,
    pub argmin: Option<ArrayData>,
    pub argmax: Option<ArrayData>,
    pub negative: Option<ArrayData>,
    pub abs: Option<ArrayData>,
    pub sqrt: Option<ArrayData>,
    pub square: Option<ArrayData>,
    pub flatten: Option<ArrayData>,
    pub reshape_flat: Option<ArrayData>,
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReductionOps {
    #[serde(flatten)]
    pub axis_operations: std::collections::HashMap<String, ArrayData>,
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UfuncOps {
    pub add: Option<ArrayData>,
    pub subtract: Option<ArrayData>,
    pub multiply: Option<ArrayData>,
    pub divide: Option<ArrayData>,
    pub equal: Option<ArrayData>,
    pub less: Option<ArrayData>,
    pub greater: Option<ArrayData>,
    pub logical_and: Option<ArrayData>,
    pub logical_or: Option<ArrayData>,
    pub logical_xor: Option<ArrayData>,
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArrayData {
    pub shape: Vec<usize>,
    pub dtype: String,
    pub data: serde_json::Value,
}

impl ArrayData {
    pub fn to_f64_array(&self) -> Result<Array<f64>, String> {
        let flat = self.to_vec_f64()?;
        if !self.shape.is_empty() && self.shape.iter().product::<usize>() != flat.len() {
            return Err("Shape/data size mismatch".to_string());
        }
        Ok(Array::from_data(flat, self.shape.clone()))
    }

    pub fn to_bool_array(&self) -> Result<Array<bool>, String> {
        let flat = self.to_vec_bool()?;
        if !self.shape.is_empty() && self.shape.iter().product::<usize>() != flat.len() {
            return Err("Shape/data size mismatch".to_string());
        }
        Ok(Array::from_data(flat, self.shape.clone()))
    }

    pub fn to_vec_f64(&self) -> Result<Vec<f64>, String> {
        match &self.data {
            serde_json::Value::Number(n) => {
                let value = n.as_f64().ok_or("Invalid number")?;
                Ok(vec![value])
            }
            serde_json::Value::Array(arr) => arr
                .iter()
                .map(|item| {
                    item.as_f64()
                        .ok_or_else(|| "Invalid number in array".to_string())
                })
                .collect(),
            _ => Err("Unsupported data format".to_string()),
        }
    }

    pub fn to_vec_bool(&self) -> Result<Vec<bool>, String> {
        match &self.data {
            serde_json::Value::Bool(value) => Ok(vec![*value]),
            serde_json::Value::Array(arr) => arr
                .iter()
                .map(|item| {
                    item.as_bool()
                        .ok_or_else(|| "Invalid bool in array".to_string())
                })
                .collect(),
            _ => Err("Unsupported data format".to_string()),
        }
    }
}

/// Load golden data from JSON file
fn load_golden_data<P: AsRef<Path>>(path: P) -> Result<GoldenData, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(path)?;
    let data: GoldenData = serde_json::from_str(&content)?;
    Ok(data)
}

/// Compare two arrays with appropriate tolerance
fn assert_f64_arrays_match(golden: &ArrayData, computed: &Array<f64>) -> Result<(), String> {
    let golden_array = golden.to_f64_array()?;

    if golden_array.shape() != computed.shape() {
        return Err(format!(
            "Shape mismatch: golden {:?} vs computed {:?}",
            golden_array.shape(),
            computed.shape()
        ));
    }

    let tolerance = if golden.dtype.contains("float") {
        1e-6
    } else {
        0.0
    };
    let golden_flat = golden_array.to_vec();
    let computed_flat = computed.to_vec();

    for (idx, (golden_val, computed_val)) in
        golden_flat.iter().zip(computed_flat.iter()).enumerate()
    {
        if golden_val.is_nan() && computed_val.is_nan() {
            continue;
        }
        let diff = (golden_val - computed_val).abs();
        if diff > tolerance {
            return Err(format!(
                "Value mismatch at {}: golden {} vs computed {}",
                idx, golden_val, computed_val
            ));
        }
    }

    Ok(())
}

fn assert_bool_arrays_match(golden: &ArrayData, computed: &Array<bool>) -> Result<(), String> {
    let golden_array = golden.to_bool_array()?;

    if golden_array.shape() != computed.shape() {
        return Err(format!(
            "Shape mismatch: golden {:?} vs computed {:?}",
            golden_array.shape(),
            computed.shape()
        ));
    }

    let golden_flat = golden_array.to_vec();
    let computed_flat = computed.to_vec();

    for (idx, (golden_val, computed_val)) in
        golden_flat.iter().zip(computed_flat.iter()).enumerate()
    {
        if golden_val != computed_val {
            return Err(format!(
                "Value mismatch at {}: golden {} vs computed {}",
                idx, golden_val, computed_val
            ));
        }
    }

    Ok(())
}

/// Test basic operations
fn test_basic_operations(input: &ArrayData, basic_ops: &BasicOps) -> Result<(), String> {
    let input_array = input.to_f64_array()?;

    if let Some(golden_sum) = &basic_ops.sum {
        let computed = input_array
            .sum(None, false)
            .map_err(|err| format!("sum failed: {}", err))?;
        assert_f64_arrays_match(golden_sum, &computed)?;
    }

    if let Some(golden_mean) = &basic_ops.mean {
        let computed = input_array
            .mean(None, false)
            .map_err(|err| format!("mean failed: {}", err))?;
        assert_f64_arrays_match(golden_mean, &computed)?;
    }

    if let Some(golden_min) = &basic_ops.min {
        let computed = input_array
            .min(None, false)
            .map_err(|err| format!("min failed: {}", err))?;
        assert_f64_arrays_match(golden_min, &computed)?;
    }

    if let Some(golden_max) = &basic_ops.max {
        let computed = input_array
            .max(None, false)
            .map_err(|err| format!("max failed: {}", err))?;
        assert_f64_arrays_match(golden_max, &computed)?;
    }

    if let Some(golden_neg) = &basic_ops.negative {
        let computed = input_array
            .negative(None, Casting::SameKind)
            .map_err(|err| format!("negative failed: {}", err))?;
        assert_f64_arrays_match(golden_neg, &computed)?;
    }

    if let Some(golden_abs) = &basic_ops.abs {
        let computed = input_array
            .abs(None, Casting::SameKind)
            .map_err(|err| format!("abs failed: {}", err))?;
        assert_f64_arrays_match(golden_abs, &computed)?;
    }

    Ok(())
}

/// Test reduction operations
fn test_reduction_operations(
    input: &ArrayData,
    reduction_ops: &ReductionOps,
) -> Result<(), String> {
    let input_array = input.to_f64_array()?;

    for (op_name, golden_result) in &reduction_ops.axis_operations {
        if let Some(axis_str) = op_name.strip_prefix("sum_axis_") {
            let axis = if axis_str == "all" {
                None
            } else {
                let axis_vals = axis_str
                    .split('_')
                    .map(|val| val.parse::<isize>().map_err(|_| "Invalid axis".to_string()))
                    .collect::<Result<Vec<isize>, String>>()?;
                Some(axis_vals)
            };
            let computed = input_array
                .sum(axis.as_deref(), false)
                .map_err(|err| format!("sum reduction failed: {}", err))?;
            assert_f64_arrays_match(golden_result, &computed)?;
        }
    }

    Ok(())
}

fn test_ufunc_operations(
    input: &ArrayData,
    operands: Option<&Operands>,
    ufunc_ops: &UfuncOps,
) -> Result<(), String> {
    let input_array = input.to_f64_array()?;
    let operands = operands.ok_or("Missing operands for ufunc operations".to_string())?;

    if let Some(golden_add) = &ufunc_ops.add {
        let rhs = operands
            .binary
            .get("add")
            .ok_or("Missing rhs for add".to_string())?
            .to_f64_array()?;
        let computed = input_array
            .add(&rhs, None, Casting::SameKind)
            .map_err(|err| format!("add failed: {}", err))?;
        assert_f64_arrays_match(golden_add, &computed)?;
    }

    if let Some(golden_multiply) = &ufunc_ops.multiply {
        let rhs = operands
            .binary
            .get("multiply")
            .ok_or("Missing rhs for multiply".to_string())?
            .to_f64_array()?;
        let computed = input_array
            .multiply(&rhs, None, Casting::SameKind)
            .map_err(|err| format!("multiply failed: {}", err))?;
        assert_f64_arrays_match(golden_multiply, &computed)?;
    }

    if let Some(golden_greater) = &ufunc_ops.greater {
        let rhs = operands
            .comparison
            .get("greater")
            .ok_or("Missing rhs for greater".to_string())?
            .to_f64_array()?;
        let computed = input_array
            .greater(&rhs)
            .map_err(|err| format!("greater failed: {}", err))?;
        assert_bool_arrays_match(golden_greater, &computed)?;
    }

    if let Some(golden_equal) = &ufunc_ops.equal {
        let rhs = operands
            .comparison
            .get("equal")
            .ok_or("Missing rhs for equal".to_string())?
            .to_f64_array()?;
        let computed = input_array
            .equal(&rhs)
            .map_err(|err| format!("equal failed: {}", err))?;
        assert_bool_arrays_match(golden_equal, &computed)?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_golden_data_conformance() {
        // Look for golden data file in standard locations
        let golden_paths = [
            "testing_framework/output/golden_data.json",
            "tests/golden_data.json",
            "golden_data.json",
            "../golden_data.json",
            "../../scripts/golden_data.json",
            "../../../scripts/golden_data.json",
        ];

        for path in &golden_paths {
            println!("Checking for golden data at: {}", path);
            println!("Exists: {}", Path::new(path).exists());
        }

        let golden_data = golden_paths
            .iter()
            .find_map(|path| {
                if Path::new(path).exists() {
                    println!("Found golden data at: {}", path);
                    load_golden_data(path).ok()
                } else {
                    None
                }
            })
            .expect(
                "Golden data file not found. Run `uv run scripts/generate_golden_data.py` first.",
            );

        println!(
            "Loaded {} test cases from golden data",
            golden_data.test_cases.len()
        );
        println!("NumPy version: {}", golden_data.metadata.numpy_version);
        println!("Seed: {}", golden_data.metadata.seed);

        let mut passed = 0;
        let mut failed = 0;

        for test_case in &golden_data.test_cases {
            println!("Running test case {}...", test_case.id);

            let mut case_passed = true;

            // Test basic operations
            if let Some(basic_ops) = &test_case.operations.basic {
                if let Err(e) = test_basic_operations(&test_case.input, basic_ops) {
                    println!("  Basic operations failed: {}", e);
                    case_passed = false;
                }
            }

            // Test reduction operations
            if let Some(reduction_ops) = &test_case.operations.reductions {
                if let Err(e) = test_reduction_operations(&test_case.input, reduction_ops) {
                    println!("  Reduction operations failed: {}", e);
                    case_passed = false;
                }
            }

            if let Some(ufunc_ops) = &test_case.operations.ufuncs {
                if let Err(e) =
                    test_ufunc_operations(&test_case.input, test_case.operands.as_ref(), ufunc_ops)
                {
                    println!("  Ufunc operations failed: {}", e);
                    case_passed = false;
                }
            }

            if case_passed {
                passed += 1;
            } else {
                failed += 1;
            }
        }

        println!("\nResults:");
        println!("  Passed: {}", passed);
        println!("  Failed: {}", failed);

        if failed > 0 {
            panic!("{} test cases failed conformance verification", failed);
        }
    }

    #[test]
    fn test_array_data_conversion() {
        let array_data = ArrayData {
            shape: vec![2, 3],
            dtype: "float64".to_string(),
            data: serde_json::json!([1.0, 2.0, 3.0, 4.0, 5.0, 6.0]),
        };

        let array = array_data.to_f64_array().unwrap();
        assert_eq!(array.shape(), &[2, 3]);
        println!("Array conversion test passed");
    }
}
