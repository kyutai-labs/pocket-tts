use std::fmt;
use std::sync::Arc;

use crate::dtype::Dtype;
use crate::error::{NumPyError, Result};
use crate::memory::MemoryManager;
use crate::strides::{compute_strides, is_c_contiguous, is_f_contiguous};

/// Multi-dimensional array structure mirroring NumPy's ndarray
pub struct Array<T> {
    data: Arc<MemoryManager<T>>,
    shape: Vec<usize>,
    strides: Vec<isize>,
    dtype: Dtype,
    offset: usize,
}

/// Immutable view into an array
#[allow(dead_code)]
pub struct ArrayView<'a, T> {
    data: &'a [T],
    shape: Vec<usize>,
    strides: Vec<isize>,
    dtype: Dtype,
    offset: usize,
}

/// Mutable view into an array
#[allow(dead_code)]
pub struct ArrayViewMut<'a, T> {
    data: &'a mut [T],
    shape: Vec<usize>,
    strides: Vec<isize>,
    dtype: Dtype,
    offset: usize,
}

impl<T> Array<T> {
    /// Get array shape
    pub fn shape(&self) -> &[usize] {
        &self.shape
    }

    /// Get strides
    pub fn strides(&self) -> &[isize] {
        &self.strides
    }

    /// Get data offset
    pub fn offset(&self) -> usize {
        self.offset
    }

    /// Get number of dimensions
    pub fn ndim(&self) -> usize {
        self.shape.len()
    }

    /// Get total number of elements
    pub fn size(&self) -> usize {
        self.shape.iter().product()
    }

    /// Get dtype
    pub fn dtype(&self) -> &Dtype {
        &self.dtype
    }

    /// Check if array is C-contiguous
    pub fn is_c_contiguous(&self) -> bool {
        is_c_contiguous(&self.shape, &self.strides)
    }

    /// Check if array is Fortran-contiguous
    pub fn is_f_contiguous(&self) -> bool {
        is_f_contiguous(&self.shape, &self.strides)
    }

    /// Get data as slice (only works for contiguous arrays)
    pub fn as_slice(&self) -> Result<&[T]> {
        if self.is_c_contiguous() && self.offset == 0 {
            Ok(self.data.as_slice())
        } else {
            Err(NumPyError::NotContiguous)
        }
    }

    /// Get element at linear index
    pub fn get(&self, index: usize) -> Option<&T> {
        if index < self.size() {
            // Calculate actual memory offset
            let linear_idx = self.offset + index;
            self.data.get(linear_idx)
        } else {
            None
        }
    }

    /// Create view of this array
    pub fn view(&self) -> ArrayView<'_, T> {
        ArrayView {
            data: self.data.as_slice(),
            shape: self.shape.clone(),
            strides: self.strides.clone(),
            dtype: self.dtype.clone(),
            offset: self.offset,
        }
    }

    /// Clone array (copy-on-write semantics)
    pub fn clone(&self) -> Self {
        Self {
            data: self.data.clone(),
            shape: self.shape.clone(),
            strides: self.strides.clone(),
            dtype: self.dtype.clone(),
            offset: self.offset,
        }
    }

    /// Reshape array (returns new view if possible)
    pub fn reshape(&self, new_shape: Vec<usize>) -> Result<Self> {
        if self.size() != new_shape.iter().product::<usize>() {
            return Err(NumPyError::shape_mismatch(vec![self.size()], new_shape));
        }

        if self.is_c_contiguous() {
            // Can create view with new strides
            let new_strides = compute_strides(&new_shape);
            Ok(Self {
                data: self.data.clone(),
                shape: new_shape,
                strides: new_strides,
                dtype: self.dtype.clone(),
                offset: self.offset,
            })
        } else {
            // Need to copy and reorganize data.
            // This part requires T: Clone + Default, so it should be in the other impl block or handled differently.
            // Since this block doesn't have T bounds, we can't call clone_contiguous() if it requires bounds.
            // We can return an error or move reshape to the bounded block?
            // Actually, reshape on non-contiguous array DOES imply copying, so T MUST be Clone.
            // So reshape should probably be in the bounded block.
            Err(NumPyError::NotContiguous) // Placeholder, see note below
        }
    }

    /// Transpose array (swap axes)
    pub fn t(&self) -> Self {
        if self.ndim() <= 1 {
            return self.clone();
        }

        let mut new_shape = self.shape.clone();
        new_shape.reverse();

        let mut new_strides = self.strides.clone();
        new_strides.reverse();

        Self {
            data: self.data.clone(),
            shape: new_shape,
            strides: new_strides,
            dtype: self.dtype.clone(),
            offset: self.offset,
        }
    }
}

impl<T> Array<T>
where
    T: Clone + Default + 'static,
{
    /// Create new array from vector data
    pub fn from_vec(data: Vec<T>) -> Self {
        let len = data.len();
        let shape = vec![len];
        let strides = vec![1];
        let dtype = Dtype::from_type::<T>();

        Self {
            data: Arc::new(MemoryManager::from_vec(data)),
            shape,
            strides,
            dtype,
            offset: 0,
        }
    }

    /// Create array from vector and shape
    pub fn from_shape_vec(shape: Vec<usize>, data: Vec<T>) -> Result<Self> {
        let expected_size: usize = shape.iter().product();
        if expected_size != data.len() {
            return Err(NumPyError::shape_mismatch(
                vec![expected_size],
                vec![data.len()],
            ));
        }

        let strides = compute_strides(&shape);
        let dtype = Dtype::from_type::<T>();

        Ok(Self {
            data: Arc::new(MemoryManager::from_vec(data)),
            shape,
            strides,
            dtype,
            offset: 0,
        })
    }

    /// Create array filled with zeros
    pub fn zeros(shape: Vec<usize>) -> Self {
        let size = shape.iter().product();
        let data = vec![T::default(); size];
        Self::from_shape_vec(shape, data).unwrap()
    }

    /// Create array filled with ones
    pub fn ones(shape: Vec<usize>) -> Self
    where
        T: From<i32>,
    {
        let size = shape.iter().product();
        let data = vec![T::from(1); size];
        Self::from_shape_vec(shape, data).unwrap()
    }

    /// Create array filled with specified value
    pub fn full(shape: Vec<usize>, value: T) -> Self {
        let size = shape.iter().product();
        let data = vec![value; size];
        Self::from_shape_vec(shape, data).unwrap()
    }

    /// Reshape array (returns new view if possible) with data copy if needed
    pub fn reshape_clone(&self, new_shape: Vec<usize>) -> Result<Self> {
        if self.size() != new_shape.iter().product::<usize>() {
            return Err(NumPyError::shape_mismatch(vec![self.size()], new_shape));
        }

        if self.is_c_contiguous() {
            self.reshape(new_shape)
        } else {
            // Need to copy and reorganize data
            self.clone_contiguous().reshape(new_shape)
        }
    }

    /// Force contiguous copy of data
    pub fn clone_contiguous(&self) -> Self {
        let mut new_data = Vec::with_capacity(self.size());

        // Copy elements in C order
        for i in 0..self.size() {
            if let Some(element) = self.get(i) {
                new_data.push(element.clone());
            }
        }

        let new_strides = compute_strides(&self.shape);
        Self {
            data: Arc::new(MemoryManager::from_vec(new_data)),
            shape: self.shape.clone(),
            strides: new_strides,
            dtype: self.dtype.clone(),
            offset: 0,
        }
    }

    /// Get mutable element at linear index (implements copy-on-write)
    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {
        if index < self.size() {
            let linear_idx = self.offset + index;
            // Ensure unique access
            Arc::make_mut(&mut self.data).get_mut(linear_idx)
        } else {
            None
        }
    }

    /// Set element at linear index
    pub fn set(&mut self, index: usize, value: T) -> Result<()> {
        if let Some(elem) = self.get_mut(index) {
            *elem = value;
            Ok(())
        } else {
            Err(NumPyError::index_error(index, self.size()))
        }
    }

    /// Compute dot product with another array
    pub fn dot(&self, other: &Array<T>) -> Result<Array<T>>
    where
        T: std::ops::Mul<Output = T> + std::ops::Add<Output = T>,
    {
        // Simplified matrix multiplication for 2D arrays
        if self.ndim() == 2 && other.ndim() == 2 {
            let (m, k1) = (self.shape[0], self.shape[1]);
            let (k2, n) = (other.shape[0], other.shape[1]);
            
            if k1 != k2 {
                return Err(NumPyError::shape_mismatch(
                    self.shape().to_vec(),
                    other.shape().to_vec(),
                ));
            }
            
            // Compute matrix product using naive algorithm
            let mut result_data = Vec::with_capacity(m * n);
            for i in 0..m {
                for j in 0..n {
                    let mut sum = T::default();
                    for k in 0..k1 {
                        let idx_a = i * k1 + k;
                        let idx_b = k * n + j;
                        if let (Some(a), Some(b)) = (self.get(idx_a), other.get(idx_b)) {
                            sum = sum + a * b;
                        }
                    }
                    result_data.push(sum);
                }
            }
            
            Ok(Array::from_data(result_data, vec![m, n]))
        } else {
            Err(NumPyError::not_implemented("Dot product only implemented for 2D arrays"))
        }
    }
    
    /// Fancy indexing with integer arrays (like arr[[1,3,5]])
    pub fn fancy_index(&self, indices: &Array<usize>) -> Result<Array<T>> {
        if indices.ndim() > 1 {
            return Err(NumPyError::not_implemented("Multi-dimensional fancy indexing not yet implemented"));
        }
        
        if indices.size() != 1 {
            return Err(NumPyError::not_implemented("Only single-element fancy indexing implemented"));
        }
        
        if let Some(idx) = indices.get(0) {
            self.basic_index(&[idx])
        } else {
            Err(NumPyError::index_error(0, self.size()))
        }
    }

    /// Get element by multi-dimensional indices
    pub fn get_by_indices(&self, indices: &[usize]) -> Result<&T> {
        if indices.len() != self.ndim() {
            return Err(NumPyError::index_error(indices.len(), self.ndim()));
        }

        let linear_idx = crate::strides::compute_linear_index(indices, self.strides());
        self.get(linear_idx).ok_or_else(|| NumPyError::index_error(linear_idx, self.size()))
    }

    /// Set element by multi-dimensional indices
    pub fn set_by_indices(&mut self, indices: &[usize], value: T) -> Result<()> {
        if indices.len() != self.ndim() {
            return Err(NumPyError::index_error(indices.len(), self.ndim()));
        }

        let linear_idx = crate::strides::compute_linear_index(indices, self.strides());
        self.set(linear_idx, value)
    }

    /// Count elements that are reduced over for each output position
    pub fn count_reduced_elements(&self, axis: Option<&[isize]>, keepdims: bool) -> Result<Array<i64>> {
        let output_shape = crate::broadcasting::broadcast_shape_for_reduce(
            self.shape(),
            axis.unwrap_or(&[]),
            keepdims
        );

        let count = if let Some(reduction_axes) = axis {
            let mut count_val = 1i64;
            for &ax in reduction_axes {
                let ax = if ax < 0 {
                    ax + self.ndim() as isize
                } else {
                    ax
                } as usize;

                if ax < self.ndim() {
                    count_val *= self.shape()[ax] as i64;
                }
            }
            count_val
        } else {
            self.size() as i64
        };

        Ok(Array::full(output_shape, count))
    }
    
    /// Boolean masking (arr[arr > 0])
    pub fn boolean_mask(&self, mask: &Array<bool>) -> Result<Array<T>> {
        if self.shape() != mask.shape() {
            return Err(NumPyError::shape_mismatch(
                self.shape().to_vec(),
                mask.shape().to_vec(),
            ));
        }
        
        if mask.shape().is_empty() {
            return Ok(Array::empty());
        }
        
        let mut result_data = Vec::new();
        for (i, &mask_val) in mask.data.iter().enumerate() {
            if mask_val && i < self.data.len() {
                if let Some(element) = self.get(i) {
                    result_data.push(element.clone());
                }
            }
        }
        
        Ok(Array::from_data(result_data, vec![]))
    }
    
    /// Ellipsis indexing (arr[..., 1])
    pub fn ellipsis_index(&self, indices: &[std::ops::Index]) -> Result<Array<T>> {
        use std::ops::Index;
        
        let mut explicit_dims = 0;
        let mut ellipsis_pos = None;
        
        // Count explicit dimensions and find ellipsis
        for (i, idx) in indices.iter().enumerate() {
            match idx {
                Index::Ellipsis => {
                    if ellipsis_pos.is_some() {
                        return Err(NumPyError::invalid_operation("Only one ellipsis allowed"));
                    }
                    ellipsis_pos = Some(i);
                },
                    crate::slicing::Index::Integer(_) | crate::slicing::Index::Slice(_) | crate::slicing::Index::Boolean(_) => {
                    explicit_dims += 1;
                },
            }
        }
        
        if explicit_dims > self.ndim() {
            return Err(NumPyError::invalid_operation(&format!(
                "Too many indices for {}-D array", self.ndim())));
        }
        
        let implicit_dims = match ellipsis_pos {
            Some(pos) => self.ndim() - explicit_dims,
            None => 0,
        };
        
        // Convert to basic indices
        let mut basic_indices = Vec::new();
        for i in 0..self.ndim() {
            if let Some(idx) = indices.get(i) {
                basic_indices.push(idx);
            } else if ellipsis_pos.is_some() && i >= ellipsis_pos.unwrap() {
                // Fill with slice for ellipsis expansion
                use crate::slicing::Slice;
                basic_indices.push(Slice { start: 0, stop: isize::MAX, step: 1 });
            }
        }
        
        self.apply_multi_index(&basic_indices)
    }
    
    /// Field access for structured arrays (arr['field_name'])
    pub fn field_access(&self, field_name: &str) -> Result<Array<u8>> {
        match &self.dtype {
            Dtype::Struct(fields) => {
                for field in fields {
                    if field.name == field_name {
                        // Extract field data based on offset and dtype
                        let mut field_data = Vec::new();
                        for i in 0..self.size() {
                            let byte_offset = field.offset.unwrap_or(0) + i * field.dtype.itemsize();
                            let array_bytes = Arc::make_mut(&mut self.data).as_bytes();
                            if byte_offset + field.dtype.itemsize() <= array_bytes.len() {
                                field_data.extend_from_slice(&array_bytes[byte_offset..byte_offset + field.dtype.itemsize()]);
                            }
                        }
                        return         Ok(Array::from_data(field_data, vec![field_data.len()]));
                    }
                }
                Err(NumPyError::invalid_operation(&format!(
                    "Field '{}' not found in structured array", field_name)))
            },
            _ => Err(NumPyError::invalid_operation("Field access only available for structured arrays")),
        }
    }
    
    /// Add new axis (arr[np.newaxis, :])
    pub fn add_newaxis(&self, axis: usize) -> Result<Array<T>> {
        if axis > self.ndim() {
            return Err(NumPyError::index_error(axis, self.ndim()));
        }
        
        let mut new_shape = self.shape().to_vec();
        new_shape.insert(axis, 1);
        
        // Reshape array with new axis
        self.reshape(&new_shape)
    }
}

impl<T> Array<T> where T: Clone + Default + 'static {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Array(shape={:?}, dtype={:?})", self.shape, self.dtype)
    }
    
    /// Create array from data vector and shape
    pub fn from_data(data: Vec<T>, shape: Vec<usize>) -> Self where T: Clone {
            let dtype = Dtype::from();
        let strides = compute_strides(&shape);
        let memory_manager = Arc::new(MemoryManager::from_vec(data));
        Self {
            data: memory_manager,
            shape,
            strides,
            dtype,
            offset: 0,
        }
    }
    
    /// Get array as vector (consumes the array)
    pub fn to_vec(&self) -> Vec<T> where T: Clone {
        self.data.as_ref().as_vec().to_vec()
    }
    
    /// Get array shape
    pub fn shape(&self) -> &[usize] {
        &self.shape
    }
    
    /// Get array strides
    pub fn strides(&self) -> &[isize] {
        &self.strides
    }
    
    /// Get array dtype
    pub fn dtype(&self) -> Dtype {
        self.dtype
    }
    
    /// Convert to ndarray 2D matrix
    pub fn to_ndarray2(&self) -> Result<ndarray::Array2<T>, NumPyError>
        if self.ndim() != 2 {
            return Err(NumPyError::invalid_operation("to_ndarray2 requires 2D array"));
        }
        
        let (rows, cols) = (self.shape()[0], self.shape()[1]);
        let data = self.data.as_ref().as_vec();
        ndarray::Array2::from_shape_vec((rows, cols), data.to_vec())
            .map_err(|e| NumPyError::invalid_operation(&e.to_string()))
    }
    
    /// Convert from ndarray 2D matrix
    pub fn from_ndarray(array: ndarray::ArrayD<T>) -> Self where T: Clone {
        let shape = array.shape().to_vec();
        let strides = compute_strides(&shape);
        let memory_manager = Arc::new(MemoryManager::from_vec(array.into_raw_vec()));
        Self {
            data: memory_manager,
            shape,
            strides,
            dtype: Dtype::from(),
            offset: 0,
        }
    }
}

impl<T> fmt::Display for Array<T>
where
    T: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Simplified display - real NumPy has sophisticated formatting
        if self.ndim() == 1 {
            write!(f, "[")?;
            for (i, _elem) in (0..self.size()).take(10).enumerate() {
                if i > 0 {
                    write!(f, ", ")?;
                }
                if let Some(val) = self.get(i) {
                    write!(f, "{}", val)?;
                }
            }
            if self.size() > 10 {
                write!(f, "...")?;
            }
            write!(f, "]")
        } else {
            write!(f, "Array({:?})", self.shape)
        }
    }
}
